---
layout: post
title: 'Python中变量初始化及拷贝问题'
description: 'Python底层变量初始化及深拷贝浅拷贝探究'
categories: [Python]
tags: []
image:  /assets/img/blog/python.png
# invert_sidebar: true

related_posts:
  - 
---
- Table of Contents
{:toc .large-only}
Python中所有变量都是内存地址的引用，变量通过绑定内存地址的方式指向内存中的值。

这里说的不可变指的是值的不可变。 对于不可变类型的变量，如果要更改变量，则会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收。 

可变类型数据对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它绑定的地址会保持不变，但区域会变长或者变短，该区域内存储的是其他值的内存地址。

### 变量初始化

创建变量时候，解释器会在内存中新开一个空间 把变量内容放进去 由指针指向内存的地址

然后由变量引用指针

![set](/assets/img/python_copy/set.png)

在python中可以使用``id()``函数查看内存地址

```python
a = "a"
print(id(a))
```

有了这个地址我们也可以主动去获取里面的值

```python
import ctypes
# 读取内存地址中的值
def get_address_value(address):
    get_value = ctypes.cast(address, ctypes.py_object).value  # 读取地址中的变量

    print(address, get_value)
```

每当我们使用这个变量时 其实内部逻辑跟上面是一样的 从内存地址中读取内容 返回输出

### 整数缓存

如果定义的是数字类型的话 解释器会去 ``整数缓冲区`` 查找 如果没有才会新创建地址

Python解释器会开辟一个整数缓冲区 对 -5 - 256的整数进行缓存

不管多少次启动程序  256以内的数字的内存地址都是一样的

![Integer_buffer](/assets/img/python_copy/Integer_buffer.png)

### List变量声明

列表本质上是一个数组  在内存中开辟一个空间 存储带内存指针的数组

而内存指针指向的才是真实的数据

![array_memory](/assets/img/python_copy/array_memory.png)

比如：

```python
a = [1,2,3,4]

就相当于
a变量指向数组的内存id 1673665322568

1673665322568 指向的内存空间是这样的
[1的内存指针,2的内存指针,...]

1的内存指针指向的内存id是从整数缓冲区里取到的
```

如果是嵌套列表的话

```python
a = [1,[2,3]]

列表的第二位指向的的是嵌套列表的内存地址
2902664748616

[1的内存指针,嵌套列表的内存指针]

而嵌套列表的内存指针指向的是 2902664748616

2902664748616的内容是 [2的内存指针,3的内存指针,...] 以此类推
```

![nested_list_memory](/assets/img/python_copy/nested_list_memory.png)

### 参数传递

当变量作为参数传递给函数的时候，会将变量引用的内存地址赋给函数参数，可见函数内部和外部的内存地址是一样的

```python
a = "ABCD"

def test(b):
    print(id(b))

print(id(a))
test(a)

# 3016014578440
# 3016014578440
```

#### 函数内修改可变类型

可变类型作为参数传入函数时 函数内使用该变量自身的方法添加/删除 会直接影响函数外的变量

比如 append remove 对变量自身操作

```python
a = [1, 2, 3, 4]

def test(b):
    print(id(b))
	# 对b尾部添加元素
    b.append(5)
    b.remove(1)
    print(b)
    print(id(b))


print(a)
print(id(a))

test(a)

print(a)

# [1, 2, 3, 4]
# 1486833913672
# 1486833913672
# [2, 3, 4, 5]
# 1486833913672
# [2, 3, 4, 5]
```

#### 函数内修改不可变类型

不可变类型没有自身的方法去对元素新增/删除 只有使用系统修改方法 `=` 或者`+=`才会对数据做修改

如果使用 = 重新赋值的话 就会生成新的内存地址 从而不会影响外部变量数据

```python
a = "ABCD"

def test(b):
    print(id(b))
    # 对b尾部添加字符
    b += "E"
    print(b)
    print(id(b))


print(a)
print(id(a))

test(a)

print(a)
print(id(a))

# ABCD
# 2286730935408
# 2286730935408
# ABCDE
# 2286730935240
# ABCD
# 2286730935408
```

当变量`a` 作为参数传入的时候地址还是 ...08，修改之后变成了...40

一旦对不可变类型的变量进行修改 它会重新开辟空间进行存储 对本身的地址不会影响

### 深拷贝&浅拷贝

#### 拷贝不可变类型

```python
import copy
yuan = "A1"

a = copy.copy(yuan)
b = copy.deepcopy(yuan)

print(id(yuan), id(a), id(b))
# 1782866144 1782866144 1782866144
```

对于不可变类型来说 拷贝只是创建变量并且引用了其内存指针

对变量修改 只是引用的内存指针变化了 不会影响其他变量引用的指针

```python
a += "2"
print(id(yuan), id(a), id(b))
# 2152815523520 2152815524808 2152815523520
```

#### 拷贝可变类型

我们再创建一个嵌套数组 看数组中元素被拷贝后的内存地址

```python
import copy

source_list = ["a1", "b1", "c1", "d1", ["e1", {"name": "小明"}]]

a = copy.copy(source_list)
b = copy.deepcopy(source_list)

print(id(source_list), id(a), id(b)) # 可见不管用什么copy 都是新开辟一个内存地址 来存储
# 2619300120136 2619300120776 2619300122312

print(id(source_list[3]), id(a[3]), id(b[3]))  # 但是里面不可变类型的内存地址都是一样的
# 2619298282440 2619298282440 2619298282440
```

对于可变类型 深拷贝与浅拷贝都是重新开辟一个内存地址 记录内存指针

但列表中的不可变类型不会重新生成指针 可参考上面 ``拷贝不可变类型``

```python
# 那么我们看看嵌套列表的地址是否有变化
print(id(source_list[4]), id(a[4]), id(b[4]))  # 看 deepcopy的嵌套列表的地址发生了变化
# 1760279858824 1760279858824 1760279857544
```

嵌套列表中的元素是否还会改变呢？

```python
print(id(source_list[4][0]), id(a[4][0]), id(b[4][0]))  # 嵌套列表内部的值还是一样的
# 2964168836632 2964168836632 2964168836632

# 嵌套列表里的嵌套字典的内存地址还是一样的
print(id(source_list[4][1]["name"]), id(a[4][1]["name"]), id(b[4][1]["name"]))
# 2452348885808 2452348885808 2452348885808
```

深拷贝对于可变类型是新开辟一个地址 但是里面的不可变元素还是引用之前的

深拷贝对所有的可变类型都会重新开辟地址 重新记录内存指针

### 小结

浅拷贝不可变类型 只是引用了其内存指针，拷贝可变类型 会重新生成地址 但里面指针不会变化。

深拷贝不可变类型 也只是引用内存指针，但是对于可变类型 会重新生成内存并且里面的指针也会重新创建

完全是另一组数据，嵌套类型不管有多深 深拷贝每遇到可变类型都会进行重新分配。

